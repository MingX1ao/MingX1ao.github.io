<!DOCTYPE html>
<html lang="zh-cmn-Hans">

<head>
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="HandheldFriendly" content="true">
    <meta charset="UTF-8">
    <meta name="keywords" content="数据库原理">
    <meta name="description" content="2 关系代数 - 数据库原理">
    <meta name="author" content="MingXiao">
    <title>2 关系代数</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="/assets/css/global.css">
    <link rel="stylesheet" href="/assets/css/pace-theme-flash.css">
    <link rel="stylesheet" href="/assets/css/d-audio.css">
    <link rel="stylesheet" href="/assets/css/article-detail.css">
    <link rel="stylesheet" href="/assets/css/code.css">
    <link rel="stylesheet" href="/assets/css/github-markdown.css">
    <link rel="stylesheet" href="/assets/css/vditor.css">
    <link rel="stylesheet" href="/assets/css/markdown.css">
    <link rel="shortcut icon" href="/images/blog-logo.png">
    <style>
        .lazy-image {
            background: url('/images/loading.gif') no-repeat center;
            background-size: 26% 35%;
            height: 100%;
            width: 100%;
        }

        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 10px;
        }

        @media (max-width: 767px) {
            .markdown-body {
                padding: 15px;
            }

            .markdown-body h1 {
                font-size: 1.35em;
            }

        }

        .codehilite {
            border-radius: 10px;
        }

        .article-content img {
            max-width: 100%;
        }

        #outerdiv {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 200;
        }
    </style>
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
</head>
<body>
    <script src="/assets/js/include.js"></script>
    <div data-include="/includes/nav.html"></div>
        <div class="toc">
            <ul>
                <li>2 关系代数
                    <ul>
                            <li><a href="#1.1">2.1 基本概念</a></li>
                            <li><a href="#1.2">2.2 关系完整性约束</a></li>
                            <li><a href="#1.3">2.3 关系运算</a></li>
                    </ul>
                </li>
            </ul>
        </div>

    <!--主体-->
    <section class="main">
        <div class="left-box">
            <div id="outerdiv">
                <div id="innerdiv" style="position:absolute;"><img alt id="bigimg"
                        style="box-shadow: 0 0 10px rgba(0,0,0,0.38)" src="" /></div>
            </div>
            <!--文章内容-->
            <div class="article-container">
                <div class="article-content markdown-body">
                    <h1 style="margin: 10px 0">2 关系代数</h1>
                    <div class="article-cate">
                        <a href="/Category/LearningHomepage.html">学习笔记</a>
                    </div>
                    <div class="writer-info">
                        <span style="margin: 5px 0;">作者: </span>
                        <span id="writer">MingXiao</span>
                    </div>
                    <div class="typora-export os-windows">
<a name="1.1" class="md-header-anchor" id="1.1"></a>
<h3>2.1 基本概念</h3>
<table>
<thead>
<tr>
<th align="center">关系模型</th>
<th align="center">一般称呼</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关系模式</td>
<td align="center">表头</td>
</tr>
<tr>
<td align="center">关系名</td>
<td align="center">表名</td>
</tr>
<tr>
<td align="center">关系</td>
<td align="center">二维表</td>
</tr>
<tr>
<td align="center">元组</td>
<td align="center">行/记录</td>
</tr>
<tr>
<td align="center">属性</td>
<td align="center">列</td>
</tr>
<tr>
<td align="center">属性名</td>
<td align="center">列名</td>
</tr>
<tr>
<td align="center">属性值</td>
<td align="center">列值</td>
</tr>
<tr>
<td align="center">分量</td>
<td align="center">一条记录的一个列值</td>
</tr>
</tbody></table>
<p><strong>关系模式</strong>：\(R(A_1,A_2,\ldots,A_n)\)，如火车票记录（乘客，车次，......）</p>
<p><strong>属性</strong>：有属性名和属性域定义，有属性值赋给每一个元组</p>
<p><strong>元组</strong>：给定的R的一次取值，记为\(t(a_1,a_2,\ldots,a_n),a_i\in Dom(A_i)\)，\(R=\{t|a_i\in Dom(A_i)\}\)</p>
<p><strong>超键</strong>：任一个属性组\((A_i,A_j,A_k,...)\)称为一个键，能在关系中<strong>唯一</strong>标识一个元组的键称为超键</p>
<p><strong>候选键</strong>：不含多余属性的超键，任去一个都不能称为超键</p>
<p><strong>主键</strong>：选定的一个候选键</p>
<p><strong>外键</strong>：派生关系的属性组，是主关系的主键，这个属性组是<strong>派生关系</strong>的外键</p>
<a name="1.2" class="md-header-anchor" id="1.2"></a>
<h3>2.2 关系完整性约束</h3>
<p><strong>实体完整性约束（主键）</strong></p>
<ol>
<li>主键的任意属性不能取空值</li>
<li>主键的取值组合不能重复</li>
</ol>
<p><strong>参照完整性约束（外键）</strong></p>
<ol>
<li>删除规则：一个实体A被另一个实体B引用，那么禁止删除A实体</li>
<li>插入规则：被引用的元素必须在数据库中存在</li>
</ol>
<p><strong>用户定义完整性约束</strong></p>
<p>用户自己定义的特殊约束</p>
<p>如：非空约束，唯一约束</p>
<p><strong>自增长约束（auto_increment）</strong></p>
<p>自动生成一个唯一的值用作新数据的值，一般作为主键</p>
<p><strong>检查约束（check（条件））</strong></p>
<p>自己定义</p>
<p><strong>默认约束（default value）</strong></p>
<p>跟在表的属性定义之后</p>
<a name="1.3" class="md-header-anchor" id="1.3"></a>
<h3>2.3 关系运算</h3>
<p><strong>计算优先级</strong>：从左到右，有括号先括号</p>
<h4>2.3.1 基本关系代数</h4>
<p><strong>选择</strong>：从关系R中获取满足条件的元组，p是谓词逻辑<br>\[
\sigma_p(R)=\{t|t\in R \and p(t)\}
\]</p>
<p><strong>投影</strong>：从R中获取某些列组成新的关系（从k个属性中取n个属性）<br>\[
\Pi_{A_1,A_2,\ldots ,A_n}=\{t[A_1,A_2,\ldots, A_n]|t\in R\}
\]</p>
<p><strong>并</strong>：两个关系取并集</p>
<p>R，S的属性个数相同，属性存在一一对应关系，每个属性的域相同</p>
<p>Union 元组不可重复；Union all 元组可以重复</p>
<p><strong>差</strong>操作同理</p>
<p><strong>笛卡尔积</strong>：与离散数学相同<br>\[
R\times S = \{(t,q)|t\in R \and q\in S\}
\]<br>\(|R\times S|=|R|\times |S|\)</p>
<p><strong>重命名</strong>：将关系R重命名为关系S，同时将各个属性重命名为\(A_i\)<br>\[
\rho_S(A_1,A_2,\ldots, A_n)(R)
\]<br>若是\(\rho_S(R)\)，则不改变属性名</p>
<h4>2.3.2 附加关系代数</h4>
<p><strong>交</strong>：不是基本运算，可以用\(A-(A-B)\)得到<br>\[
R\cap S=R-(R-S)
\]<br>用韦恩图看看，可以求不同运算</p>
<p><strong>连接</strong>：笛卡尔积加选择加投影<br>\[
R\Join_pS=\{(t,q)|t\in R\and q\in S\and p\left((t,q)\right)\}
\]<br>p是选择谓词</p>
<p><strong>等值连接</strong>：某两个属性值要相等</p>
<p><strong>自然连接</strong>：将同一个属性中属性值相同的做等值连接<br>\[
R\Join S
\]</p>
<p><strong>外连接</strong>：特殊的自然连接，可以处理缺省值</p>
<p><strong>左外连接</strong>：\(R ⟕ S\)，保留左侧的属性值，若右侧没有左侧的某个值，则用NULL缺省，若左侧不存在右侧的值，则不搬运右侧的值</p>
<p><strong>右外连接</strong>：\(R⟖S\)，同理</p>
<p><strong>全外连接</strong>：\(R⟗S\)，两边都保留，即使重复了</p>
<p><font color=red>例：</font></p>
<table>
<thead>
<tr>
<th align="center">A1</th>
<th align="center">B1</th>
<th align="center">A2</th>
<th align="center">C2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">1</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">2</td>
<td align="center">E</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">C</td>
<td align="center">4</td>
<td align="center">F</td>
</tr>
</tbody></table>
<p>表1<strong>左</strong>外连接表2得到</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">C</td>
<td align="center">NULL</td>
</tr>
</tbody></table>
<p>表1<strong>右</strong>外连接表2得到</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">NULL</td>
<td align="center">E</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">NULL</td>
<td align="center">F</td>
</tr>
</tbody></table>
<p>表1<strong>全</strong>外连接表2得到</p>
<table>
<thead>
<tr>
<th align="center">A</th>
<th align="center">B</th>
<th align="center">C</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">C</td>
<td align="center">NULL</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">A</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">B</td>
<td align="center">D</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">NULL</td>
<td align="center">E</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">NULL</td>
<td align="center">F</td>
</tr>
</tbody></table>
<p><strong>赋值</strong>：A\(\leftarrow\)E，其中E是关系运算，A是一个关系</p>
<p><strong>除</strong>：\(R\div S\)，留下S中没有的，R中存在的属性，只保留能完全保留S中的属性的值的其余属性值；S中存在R中没有的属性，不能除</p>
<table>
<thead>
<tr>
<th align="center">A_R</th>
<th align="center">B_R</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">a</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">b</td>
<td align="center">2</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">B_S</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
</tr>
<tr>
<td align="center">3</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">A_R/S</th>
</tr>
</thead>
<tbody><tr>
<td align="center">a</td>
</tr>
</tbody></table>
<p>当R中的每一个A都有所有的B时（能整除），除和笛卡尔积为逆运算</p>
<h4>2.3.3 扩展关系代数</h4>
<p><strong>广义投影</strong>：允许用算术运算和字符串函数对投影进行扩展<br>\[
\Pi_{F_1,F_2,\ldots ,F_n}(R)=\{t[B_1,B_2,\ldots, B_m]|t\in R\}
\]<br>F是对B的运算</p>
<p><strong>聚合</strong>：相当于EXCEL的筛选，可以用max，count，average等<br>\[
\mathcal{G}_{F_1(A_1),F_2(A_2),\ldots,F_n(A_n)}(R)
\]<br>F为对属性的具体操作，A为属性</p>
<p><strong>分组</strong>：先少选某些属性的值，进行分组，再聚和，相当于pandas的groupby()<br>\[
_{G_1,G_2,\ldots,G_n}\mathcal{G}_{F_1(A_1),F_2(A_2),\ldots,F_k(A_k)}(R)
\]<br>G为分组用的属性，在所有G上取值相同的将分为一组</p>
<p><strong>排序</strong>：字面意思<br>\[
\tau_{A_1,A_2,\ldots,A_n}(R)
\]<br>A是排序的属性，若前一个属性相同，则按后一个属性排序</p>

                    </div>    
                </div>
            </div>                                                                                                                                              
            <br>
            <br>
            <h2 id="__comments">Comments</h2>
                  <!-- Giscus comments -->
                    <script src="https://giscus.app/client.js"
                            data-repo="MingX1ao/MingX1ao.github.io"
                            data-repo-id="R_kgDOL_cJHA"
                            data-category="General"
                            data-category-id="DIC_kwDOL_cJHM4CgVLq"
                            data-mapping="pathname"
                            data-strict="0"
                            data-reactions-enabled="1"
                            data-emit-metadata="0"
                            data-input-position="bottom"
                            data-theme="light"
                            data-lang="zh-CN"
                            data-loading="lazy"
                            crossorigin="anonymous"
                            async>
                    </script>
        </div>
    </section>
    <!--尾部-->
    <div data-include="/includes/footer.html"></div>
    <script>
        document.addEventListener('includesReady', function() {
            const lazyImage = new LazyImage('.lazy-image');
        });
    </script>
</body>

</html>
