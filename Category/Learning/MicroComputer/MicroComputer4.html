<!DOCTYPE html>
<html lang="zh-cmn-Hans">

<head>
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="HandheldFriendly" content="true">
    <meta charset="UTF-8">
    <meta name="keywords" content="微机原理">
    <meta name="description" content="5 流程转移和子程序 - 微机原理">
    <meta name="author" content="MingXiao">
    <title>5 流程转移和子程序</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="/assets/css/global.css">
    <link rel="stylesheet" href="/assets/css/pace-theme-flash.css">
    <link rel="stylesheet" href="/assets/css/d-audio.css">
    <link rel="stylesheet" href="/assets/css/article-detail.css">
    <link rel="stylesheet" href="/assets/css/code.css">
    <link rel="stylesheet" href="/assets/css/github-markdown.css">
    <link rel="stylesheet" href="/assets/css/vditor.css">
    <link rel="stylesheet" href="/assets/css/markdown.css">
    <link rel="shortcut icon" href="/images/blog-logo.png">
    <style>
        .lazy-image {
            background: url('/images/loading.gif') no-repeat center;
            background-size: 26% 35%;
            height: 100%;
            width: 100%;
        }

        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 10px;
        }

        @media (max-width: 767px) {
            .markdown-body {
                padding: 15px;
            }

            .markdown-body h1 {
                font-size: 1.35em;
            }

        }

        .codehilite {
            border-radius: 10px;
        }

        .article-content img {
            max-width: 100%;
        }

        #outerdiv {
            width: 100%;
            height: 100%;
            position: fixed;
            top: 0;
            left: 0;
            background: rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 200;
        }
    </style>
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
</head>
<body>
    <script src="/assets/js/include.js"></script>
    <div data-include="/includes/nav.html"></div>
        <div class="toc">
            <ul>
                <li>5 流程转移和子程序
                    <ul>
                            <li><a href="#4.1">5.1 转移</a></li>
                            <li><a href="#4.2">5.2 JMP指令汇总</a></li>
                            <li><a href="#4.3">5.3 OFFSET指令</a></li>
                            <li><a href="#4.4">5.4 模块化设计程序（函数）</a></li>
                            <li><a href="#4.5">5.5 寄存器冲突问题</a></li>
                            <li><a href="#4.6">5.6 标志位寄存器</a></li>
                            <li><a href="#4.7">5.7 带进/借位的加减法</a></li>
                            <li><a href="#4.8">5.8 cmp指令和条件转移指令</a></li>
                            <li><a href="#4.9">5.9 DF标志位和串传送指令</a></li>
                    </ul>
                </li>
            </ul>
        </div>

    <!--主体-->
    <section class="main">
        <div class="left-box">
            <div id="outerdiv">
                <div id="innerdiv" style="position:absolute;"><img alt id="bigimg"
                        style="box-shadow: 0 0 10px rgba(0,0,0,0.38)" src="" /></div>
            </div>
            <!--文章内容-->
            <div class="article-container">
                <div class="article-content markdown-body">
                    <h1 style="margin: 10px 0">5 流程转移和子程序</h1>
                    <div class="article-cate">
                        <a href="/Category/LearningHomepage.html">学习笔记</a>
                    </div>
                    <div class="writer-info">
                        <span style="margin: 5px 0;">作者: </span>
                        <span id="writer">MingXiao</span>
                    </div>
                    <div class="typora-export os-windows">
<a name="4.1" class="md-header-anchor" id="4.1"></a>
<h3>5.1 转移</h3>
<p>本质是修改<code>ip</code>和<code>cs</code>的值，改变命令执行的顺序</p>
<p>分类</p>
<p>按行为：段内转移和段间转移</p>
<p>按修改范围：短转移（<code>-128-127</code>）和长转移（<code>-32768-32767</code>）</p>
<p>按指令：</p>
<ol>
<li>无条件转移：jmp</li>
<li>有条件转移：jcxz和jcxnz</li>
<li>循环指令：loop</li>
<li>过程</li>
<li>中断：int</li>
</ol>
<a name="4.2" class="md-header-anchor" id="4.2"></a>
<h3>5.2 JMP指令汇总</h3>
<p><font color=green><strong>JMP 标号</strong></font></p>
<p>标号也就是名称，如<code>s:inc bx</code>，中s为标号</p>
<ol>
<li><p><code>jmp short label</code>，段<strong>内</strong>短转移，8位，机器码是<strong>位移</strong></p>
</li>
<li><p><code>jmp near ptr label</code>，段<strong>内</strong>近转移，16位，机器码是<strong>位移</strong></p>
</li>
<li><p><code>jmp far ptr label</code>，段<strong>间</strong>转移，机器码是<strong>label的内存地址<code>CS:IP</code></strong>，按小端存储，ip地址低</p>
<pre><code class="language-assembly">jmp far ptr statr        ;假设start的位置是076A:010B，那么这条的机器码就是EA0B016A07
</code></pre>
</li>
</ol>
<p><strong>JMP 寄存器</strong></p>
<p><code>jmp bx</code>，bx是目标指令的<strong>ip地址</strong></p>
<p><strong>JMP 立即数</strong></p>
<p><code>jmp 00</code>，<code>ip = 00</code></p>
<p><code>jmp 00:00</code>，<code>cs = 00, ip = 00</code></p>
<p><strong>JMP 内存单元</strong></p>
<ol>
<li><code>jmp word ptr [address]</code>，段<strong>内</strong>转移，转到<code>[address]</code>所<strong>存储的值</strong>的位置</li>
<li><code>jmp dword ptr [address]</code>，段<strong>间</strong>转移，<code>CS=2-3[address],IP=0-1[address]</code>，dword是双字，4B</li>
</ol>
<p><strong>基于位移进行的JMP指令</strong></p>
<p>在机器码中的位移是jmp指令<strong>指向的地址</strong> - jmp指令<strong>后一条的地址</strong></p>
<pre><code class="language-assembly">mov ax, 0		;假设存在076A:0000中
jmp short s		;存在076A:0003中，对应机器码EB05,EB是jmp short的代码，05 = 0A - 05
add ax, 1		;存在076A:0005中
nop				;空指令，占1B，076A:0008
nop				;076A:0009
s:	inc ax		;076A:000A
</code></pre>
<p>为什么会是减去后一条？</p>
<p>程序执行流程：</p>
<ol>
<li>IP指向jmp，jmp指令进入指令缓冲器</li>
<li>IP += last length，指向下一条</li>
<li>jmp执行，IP += （jmp指向 - 目前指向）=（jmp指向 - jmp下一条）</li>
</ol>
<p>当要加的数值超过限定时，会报错</p>
<p><strong>转移地址在内存中的jmp指令</strong></p>
<pre><code class="language-assembly">mov ax, 0123
mov ds:[0], ax
jmp word ptr ds:[0]			;执行后，IP = 0123
</code></pre>
<p>内存地址的<strong>内容</strong>是IP的<strong>值</strong></p>
<pre><code class="language-assembly">mov ax, 0123
mov ds:[0], ax
jmp dword ptr ds:[0]		;执行后，CS=0000,IP=0123
</code></pre>
<p>存放两个字，高字是CS，底字是IP</p>
<p><strong>有条件转移：JCXZ</strong></p>
<p><code>jcxz label</code></p>
<p><code>jmp when cx == zero</code></p>
<p>当cx寄存器的值为0时，执行jmp指令（对应jcxnz）</p>
<p>机器码是label的地址 - 这条指令的下一条地址（<strong>位移</strong>），对IP的修改范围是**-128 - 127**</p>
<p><strong>循环转移：LOOP</strong></p>
<pre><code class="language-assembly">s:	add ax, ax		;设地址为076A:0006
loop s				;地址为076A:0008，机器码为E2FC
mov ax, 4c00		;地址为076A:000A
</code></pre>
<p>FC是-4的补码，表示IP -= 4，LOOP指令的机器码是<strong>位移</strong>，一般是负的</p>
<p><strong>用位移转移的好处</strong></p>
<p>无论label的位置如何，IP转移的位移是固定的，适用于调用函数指针时<strong>动态装载</strong></p>
<a name="4.3" class="md-header-anchor" id="4.3"></a>
<h3>5.3 OFFSET指令</h3>
<pre><code class="language-assembly">s:	mov ax, offset s
</code></pre>
<p>将s的偏移地址（ip）存入ax中，一定是一个<strong>16b寄存器</strong></p>
<p><font color=red>例：</font>下面是一个将s处的指令复制到s0处的代码</p>
<pre><code class="language-assembly">s:	mov ax, bx
mov si, offset s
mov di, offset s0
mov ax, cs:[si]
mov cs:[di], ax
s0:	nop
</code></pre>
<p>s0原来是空的</p>
<p>指令也是数据，由机器码形式储存，也可以mov add等，一条<code>mov ax, bx</code>指令长2B，可以用一个16b寄存器存储</p>
<a name="4.4" class="md-header-anchor" id="4.4"></a>
<h3><font color=blue>5.4 模块化设计程序（函数）</font></h3>
<p><strong>CALL指令</strong></p>
<pre><code class="language-assembly">main:
		mov ax, 0123
		call func1
		mov ax, 4c00
		int 21

fun1:
		call func2
		ret
		
fun2:
		mov bx, 2
		ret
</code></pre>
<p>call指令的实质是<strong>修改IP或IP和CS</strong></p>
<p>CPU执行call的流程：将当前的ip或cs和ip入栈（先入cs后入ip），转移到label处执行</p>
<p>call的机器码是<strong>label地址</strong> - call<strong>后第一个指令地址</strong>，也是<strong>位移</strong>，范围是<code>-32768 - 32767</code></p>
<p>类似于<code>jmp near ptr label</code>，用risc-V指令表示为</p>
<pre><code class="language-assembly">addi sp, sp, -4
lw cs, 2(sp)		;只有call far ptr有
lw ip, 0(sp)
;jmp near ptr label 这是cisc
</code></pre>
<p>同理还有<code>call far ptr</code>，实现段<strong>间</strong>转移，机器码为<strong>目标地址</strong>，小端存储，先ip后cs</p>
<p>但是，在执行过程中是<strong>CS先入栈</strong>，其实都是<code>IP</code>的地址更低</p>
<p><strong>转移地址在寄存器中的call</strong></p>
<pre><code class="language-assembly">mov ax, 0123
call ax
</code></pre>
<p>相当于</p>
<pre><code class="language-assembly">push ip
jmp near ptr ax		;ip = ax
</code></pre>
<p><strong>转移地址在内存中的call</strong></p>
<pre><code class="language-assembly">mov sp, 10H
mov ax, 0123H
mov ds:[0], ax
call word ptr ds:[0]
</code></pre>
<p>执行后，<code>ip=0123H</code>，cs不变，<code>sp=0EH</code>，sp -= 2</p>
<pre><code class="language-assembly">mov sp, 10H
mov ax, 0123H
mov ds:[0], ax
mov ds:[2], 0000H
call dword ptr ds:[0]
</code></pre>
<p>执行后，<code>ip=0123H, cs=0000H,ip=0CH</code>，高地址是cs，低地址是ip，sp -= 4</p>
<p><strong>返回指令ret/retf</strong></p>
<p>后者就是ret far，搭配call far ptr使用</p>
<pre><code class="language-assembly">fun2:
		mov bx, 2
		ret				;相当于	pop ip
</code></pre>
<pre><code class="language-assembly">fun2:
		mov bx, 2
		retf			;相当于	pop ip, pop cs
</code></pre>
<p>在实际过程中，一般要先开辟栈段</p>
<pre><code class="language-assembly">assume ss:stack, cs:code
stack segment
		db 8 dup (0)
		db 8 dup (0)
stack ends
code segment
		mov ax, stack
		mov ss, ax
		mov sp, 16
</code></pre>
<p>开辟了一个16b的栈段（<code>ss:0000H</code>到<code>ss:0015H</code>）</p>
<p><strong>ret n指令</strong></p>
<p><code>ret 4</code>等价于</p>
<pre><code class="language-assembly">pop ip
add sp, 4
</code></pre>
<p>如果函数中使用了某寄存器，在函数的开头要先将原始值入栈，在结束前对这些寄存器出栈</p>
<p>如果不是对寄存器入栈，而是一些数，则可以直接<code>ret n</code>，重新归位<code>SP</code></p>
<pre><code class="language-assembly">mov ax, 1
push ax
mov ax, 3
push ax
call func

func: 	push bp
		mov bp, sp
		;codes
		pop bp
		ret 4		;栈中还有0001H，0003H这四个字节，要归位
</code></pre>
<a name="4.5" class="md-header-anchor" id="4.5"></a>
<h3>5.5 寄存器冲突问题</h3>
<p>在处理字符串时，为了能够自动处理而不设置<code>cx = n</code>（循环次数），会在字符串末尾加上一个0</p>
<pre><code class="language-assembly">db &#39;conversation&#39;, 0
;格式省略
func:	mov si, 0H
		mov cl, [si]
		mov ch, 0H
		jcxz over
		inc si
		jmp short func
over:	ret
</code></pre>
<p>但是这样有一个问题，cx是循环控制的寄存器，这样就不能控制外层循环了</p>
<p>所以在编写的程序中必须对使用到的所有寄存器进行入栈出栈操作</p>
<p>代码修改为</p>
<pre><code class="language-assembly">func:	push cx
		push si
func1:	mov si, 0
		mov cl, [si]
		mov ch, 0H
		jcxz over
		inc si
		jmp short func1
over:	pop si
		pop cx
		ret
</code></pre>
<a name="4.6" class="md-header-anchor" id="4.6"></a>
<h3>5.6 标志位寄存器</h3>
<p><code>PSW/FLAGS</code>，是一个东西，程序状态字/标志位寄存器</p>
<p>是一个16bit寄存器，按位起作用，在8086中为</p>
<center><img src="/Category/Learning/Pictures/MicroComputer_13.png" width="300"></center>

<p>剩下的都是没用的</p>
<p>使用</p>
<pre><code class="language-assembly">pushf		;将FLAGS的值压栈
popf		;将栈顶值赋给FLAGS，弹栈
</code></pre>
<p>直接对FLAGS进行操作，此外没有办法直接操作</p>
<p>只有运算指令和部分指令的操作结果会对FLAGS产生影响，如<code>add, sub, mul, div, or, and</code>，<code>inc</code>指令不影响<code>CF</code></p>
<p>大部分传送指令对FLAGS无影响，如<code>mov, push, pop</code>等</p>
<p><strong>ZF，零标志</strong></p>
<p>记录指令的结果是否为零，即<code>zf = (result == 0)</code></p>
<pre><code class="language-assembly">sub ax, ax
</code></pre>
<p>执行后<code>ZF = 1</code></p>
<p><strong>PF，奇偶标志</strong></p>
<p>记录指令的结果的<strong>二进制</strong>表示的1的个数，<code>pf = (numOf1 == even)</code></p>
<pre><code class="language-assembly">mov ax, 0
add ax, 3
</code></pre>
<p>执行后<code>PF = 1</code></p>
<p><strong>SF，符号标志</strong></p>
<p>将所有结果都视为<strong>有符号</strong>数，<code>SF = 符号位</code>，即负数为1，正数和0为0</p>
<pre><code class="language-assembly">mov ax, 1H
add ax, F000H
</code></pre>
<p>执行后<code>SF = 1</code></p>
<p>如果数据是无符号数，那么SF没有意义，别看就行</p>
<p><strong>CF，进位标志</strong></p>
<p>只有在进行<strong>无符号数</strong>运算时，记录了结果的<strong>MSB</strong>向<strong>更高位</strong>的进位/借位，<code>CF = (有进位/借位)</code></p>
<p>如果是有符号数运算，也会记录，但是没用，不看这个就行</p>
<pre><code class="language-assembly">mov al, 98H
add al, al
</code></pre>
<p>执行后<code>CF = 1</code></p>
<p>Nbit无符号数，其最高位为N-1，注意有第0位</p>
<p><strong>OF，溢出标志</strong></p>
<p>与CF对应，这是仅针对有符号数的，<code>OF = (有溢出)</code></p>
<pre><code class="language-assembly">mov al, 98
add al, 99
</code></pre>
<p>执行后<code>OF = 1</code></p>
<a name="4.7" class="md-header-anchor" id="4.7"></a>
<h3><font color=blue>5.7 带进/借位的加减法</font></h3>
<p><code>abc</code>指令是带进位的加法，<code>abc ax, bx</code>实现了<code>ax = ax + bx + CF</code>，用于超过16bit的数的相加</p>
<p>这个例子实现了<code>1EF000H + 201000H</code></p>
<pre><code class="language-assembly">mov ax, 1EH
mov bx, F000H
add bx, 1000H
adc ax, 20H
</code></pre>
<p>将后四位给了bx，前四位给了ax</p>
<p><code>sbb</code>指令是带借位的减法，<code>sbb ax, bx</code>实现了<code>ax = ax - bx - CF</code></p>
<p>这个例子实现了<code>003E1000H - 00202000H</code></p>
<pre><code class="language-assembly">mov ax, 003EH
mov bx, 1000H
sub bx, 2000H
sbb ax, 0020H
</code></pre>
<a name="4.8" class="md-header-anchor" id="4.8"></a>
<h3><font color=green>5.8 cmp指令和条件转移指令</font></h3>
<p><code>cmp</code>是比较指令，相当于减法，但是不保存结果，<code>cmp ax, bx</code>运算<code>ax - bx</code>，但是不对<code>reg</code>造成改变，会改变<code>FLAGS</code></p>
<p><strong>jxxx指令</strong></p>
<p>没有提到寄存器（cx）的就是只对<code>FLAGS</code>进行判断</p>
<ul>
<li><code>js</code>，sign符号位，在负数时为1</li>
<li><code>jc</code>，carry进/借位，存在进/借位时为1</li>
<li><code>jp</code>，parity奇偶位，偶数为1</li>
<li><code>jo</code>，overflow溢出位，溢出为1</li>
</ul>
<p><strong>cmp和条件转移的配合</strong></p>
<pre><code class="language-assembly">cmp ah, bh
je s					;je表示ZF=1就执行
add ah, bh
jmp short over
s:		add ah, ah
over:	ret
</code></pre>
<p>相当于</p>
<pre><code class="language-c++">if (ah == bh){
	ah += ah;
}
else{
	ah += bh;
}
</code></pre>
<p>jxxx不一定配合cmp，可以单独使用，反正都是只看<code>FLAGS</code>的值</p>
<a name="4.9" class="md-header-anchor" id="4.9"></a>
<h3>5.9 DF标志位和串传送指令</h3>
<p>DF是方向标志，<code>DF = 0</code>，每次串操作后<code>si++, di++</code>；<code>DF = 1, si--, di--</code></p>
<p><strong>设置<code>DF</code>的指令</strong></p>
<p><code>cld</code>表示将<code>DF</code> clear，<code>DF = 0</code>；<code>std</code>表示将<code>DF</code> set，<code>DF = 1</code></p>
<p><font color=orange><strong>串传送指令</strong></font></p>
<p><code>movsb</code>以字节传送，功能是<code>[es:di]=[ds:si]</code>，注意是<strong>es</strong></p>
<pre><code class="language-assembly">data segment
	db &#39;Welcom&#39;
	db 6 dup (0)
data ends

code segment
start:	mov ax, data
		mov ds, ax
		mov si, 0
		mov di, 6
		mov cx, 6
		
		mov es, ax
		cld
s:		movsb
		loop s
		
		mov ax, 4c00H
		int 21H
code ends

end start
</code></pre>
<p><code>movsw</code>以字传送，串操作后<code>di+=2,si+=2</code></p>
<p><strong>rep指令</strong></p>
<p>根据cx的值，重复执行后面的指令，上面的s指令可以改成</p>
<pre><code class="language-assembly">rep movsb
</code></pre>

                    </div>    
                </div>
            </div>                                                                                                                                              
            <br>
            <br>
            <h2 id="__comments">Comments</h2>
                  <!-- Giscus comments -->
                    <script src="https://giscus.app/client.js"
                            data-repo="MingX1ao/MingX1ao.github.io"
                            data-repo-id="R_kgDOL_cJHA"
                            data-category="General"
                            data-category-id="DIC_kwDOL_cJHM4CgVLq"
                            data-mapping="pathname"
                            data-strict="0"
                            data-reactions-enabled="1"
                            data-emit-metadata="0"
                            data-input-position="bottom"
                            data-theme="light"
                            data-lang="zh-CN"
                            data-loading="lazy"
                            crossorigin="anonymous"
                            async>
                    </script>
        </div>
    </section>
    <!--尾部-->
    <div data-include="/includes/footer.html"></div>
    <script>
        document.addEventListener('includesReady', function() {
            const lazyImage = new LazyImage('.lazy-image');
        });
    </script>
</body>

</html>
